#include <bits/stdc++.h>
using namespace std;
#define int long long                     // 使用 long long 以支持更大的数值范围
int dp[25][25];                           // dp数组，用于存储从起点(0,0)到达每个点的路径数
int dx[8] = {-1, -2, -2, -1, 1, 2, 2, 1}; // 马的“日”字形走法x方向上的变化
int dy[8] = {-2, -1, 1, 2, 2, 1, -1, -2}; // 马的“日”字形走法y方向上的变化

// 主函数
signed main()
{
    int n, m, x, y;          // n, m表示棋盘大小，x, y表示马的位置
    cin >> n >> m >> x >> y; // 输入棋盘大小和马的位置

    dp[0][0] = 1; // 初始条件，起点(0,0)的路径数为1

    bool ok = 1; // 用于标记当前点是否可以走，默认可以走

    // 遍历棋盘的每一个点
    for (int i = 0; i <= n; i++) // 遍历行
    {
        for (int j = 0; j <= m; j++) // 遍历列
        {
            if (i == 0 && j == 0)
                continue; // 跳过初始点 (0,0)，因为已经初始化

            ok = 1; // 重置ok标志，表示默认该点可以走

            // 检查当前点(i,j)是否是马的位置，如果是则不能走
            if (i == x && j == y)
                ok = 0;

            // 检查当前点(i,j)是否在马的控制范围内
            for (int k = 0; k < 8; k++)
            {
                // 如果(i,j)是马的“日”字跳跃位置之一，则ok设为0，不能走
                if (i == x + dx[k] && j == y + dy[k])
                {
                    ok = 0;
                    break; // 一旦找到马控制的点就不再继续检查
                }
            }

            // 如果当前点(i,j)既不是马的位置，也不在马的控制范围内，则计算路径数
            if (ok)
            {
                // 状态转移方程，来自上方或左方的路径数之和

                // 当上方越界时，只能从左方到达
                if (i - 1 < 0)
                {
                    dp[i][j] = dp[i][j - 1];
                }
                // 当左方越界时，只能从上方到达
                else if (j - 1 < 0)
                {
                    dp[i][j] = dp[i - 1][j];
                }
                // 正常情况下，可以从上方和左方两者到达
                else
                {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }
    }

    // 输出从(0,0)到(n,m)的路径数
    cout << dp[n][m] << endl;
    return 0;
}
